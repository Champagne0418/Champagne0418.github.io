<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JVM类加载机制 | 程小可今天还是倒数吗</title><meta name="description" content="JVM类加载机制 - ChengXiaoke"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="程小可今天还是倒数吗"><link rel="stylesheet" href="/css/font-awesome.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="程小可今天还是倒数吗"><img class="logo-image" src="/favicon.ico" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/" target="_self">首页</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/archives" target="_self">归档</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/tags" target="_self">标签</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/about" target="_self">关于</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/categories" target="_self">分类</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JVM类加载机制</h1><p class="post-info"><i class="fa fa-calendar">&nbsp;</i>2020-12-03&nbsp;| <i class="fa fa-tags">&nbsp;</i><a class="post-tag-link" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入理解Java虚拟机&nbsp;·&nbsp;</a>&nbsp;| <i class="fa fa-folder-o">&nbsp;</i><a class="post-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发&nbsp;/&nbsp;</a><a class="post-category-link" href="/categories/%E5%BC%80%E5%8F%91/Java/">Java&nbsp;/&nbsp;</a><a class="post-category-link" href="/categories/%E5%BC%80%E5%8F%91/Java/JVM/">JVM&nbsp;/&nbsp;</a></p><div class="post-content"><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>大概写一写JVM类加载机制，基本就是《深入理解Java虚拟机》这本书的一个笔记吧，顺便还参考了一波搜索到的一些内容</p>
<h2 id="1-时机"><a href="#1-时机" class="headerlink" title="1. 时机"></a>1. 时机</h2><p>原则：</p>
<ul>
<li><strong>延迟加载、能不加载就不加载</strong></li>
<li>先父类后子类、先静态后非静态：<ul>
<li>例如如下顺序：父类静态、子类静态、父类非静态、父类构造函数、子类非静态、子类构造函数</li>
</ul>
</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="1-类的生命周期"><a href="#1-类的生命周期" class="headerlink" title="1. 类的生命周期"></a>1. 类的生命周期</h3><p>Class的生命周期包含<strong>七个阶段</strong></p>
<pre class="mermaid">graph TD
    load(加载)
    verify(验证)
    prepare(准备)
    resolve(解析)
    init(初始化)
    use(使用)
    unload(卸载)</pre>

<p>其中：<strong>加载、验证、准备、初始化、卸载</strong>这五个阶段必须严格按照这个顺序依次<strong>开始</strong>（指的是开始顺序，执行过程可交叉进行）</p>
<p>解析阶段不一定。是为了支持运行时绑定（动态代理、Lambda表达式等特性的基础）</p>
<p><strong>类加载过程包含前五个阶段</strong></p>
<h3 id="2-类加载过程概要："><a href="#2-类加载过程概要：" class="headerlink" title="2. 类加载过程概要："></a>2. 类加载过程概要：</h3><ol>
<li><p><strong>加载</strong>：</p>
<ul>
<li>三步：获取定义类的二进制字节流 -&gt; 转换为方法区的运行时数据结构 -&gt; 堆中生成Class对象作为该类相关的访问入口</li>
<li>字节流可来源于class字节码文件、JAR等打包后的文件、甚至是网络。</li>
</ul>
</li>
<li><p><strong>验证</strong>：</p>
<ul>
<li>主要检查四部分：<ul>
<li>文件格式是否符合Class文件规范（各部分格式与内容）</li>
<li>字节码语义是否符合语言规范（继承关系等检查）</li>
<li>字节码的数据流控制流是否安全合法且符合逻辑（最复杂）</li>
<li>符号引用是否正确匹配（访问权限等检查，<em>一般归为解析阶段</em>）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>准备</strong>：</p>
<p>简单说来就是<strong>类静态变量分配内存并设置初始值</strong>。相应的内容也存放在方法区。</p>
<p><strong><em>final修饰的赋值为指定的值，否则为对应类型的零值</em></strong></p>
</li>
<li><p><strong>解析</strong>：</p>
<p>将类的常量池中的<u>符号引用</u>（字面量表示的对象）变为<u>直接引用</u>（通过直接引用能找到这个字面量表示的对象）</p>
<p><strong>在解析得到对应的目标后必定会进行访问权限检查</strong></p>
<ul>
<li>类、接口解析：将字面量（也就是类或接口的全限定名）交给类加载器加载，若是数组类型则递归地检查元素类型（是数组类型或其他的类型、类似广义表）</li>
<li>字段解析：先解析该字段所属的类或接口。然后<u>依据类继承或接口实现树状关系，自底向上搜索，<strong>先找接口后找类</strong></u>。</li>
<li>类方法解析：仍然是先解析其所属的类，这里会先检查类，如果得到的是接口，则报错。然后依据类继承关系自底向上查找，<em>如果最终是在接口或父接口中找到，说明是抽象类，这时必定报错。</em></li>
<li>接口方法解析：和类方法解析类似。只不过检查得到所属的是类则会报错。然后自底向上查找，<em>如果最终在许多接口中都找到了对应方法，理论上是可以选择一个直接返回，但目前VM厂商基本都选择报错，防止出现问题</em>。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<p>准备阶段已经对类变量分配内存了，但还没对值真正进行初始化（非final变量暂时放的都是零值）。这个阶段<strong>相当于是执行类构造函数&lt;cinit&gt;()的过程</strong>。</p>
<blockquote>
<p>类构造函数的一些注意点：</p>
<ul>
<li>编译器自动收集<strong>静态变量赋值语句</strong>以及<strong>静态代码块</strong>生成，按照书写顺序进行，在前的语句不能访问在后面声明的变量。如果没有可被收集的代码，可不生成类构造函数</li>
<li>无需显式调用父类的类构造函数，JVM保证父类这时候<u>必定已经调用完成</u></li>
<li>多线程下只能有一个线程真正在执行这个函数，因此多线程环境下可能会有线程阻塞的问题。而且仅仅会执行一次</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="3-类加载器、双亲委派模型"><a href="#3-类加载器、双亲委派模型" class="headerlink" title="3.类加载器、双亲委派模型"></a>3.类加载器、双亲委派模型</h2><p>类加载器用于<strong>通过一个类的全限定名来获取对应类的二进制字节流</strong>。</p>
<p>不同的类加载器有各自独立的类名称空间，也就是说，<strong>两个类相等，不仅这两个类来自于同一个class文件，它们还必须是同一个类加载器加载的</strong></p>
<blockquote>
<p>equals方法、isInstance方法以及isAssignableFrom方法返回值也依据这一点</p>
</blockquote>
<h4 id="三层类加载器-双亲委派模型（Java-2-Java-8）"><a href="#三层类加载器-双亲委派模型（Java-2-Java-8）" class="headerlink" title="三层类加载器+双亲委派模型（Java 2~Java 8）"></a><strong>三层类加载器+双亲委派模型（Java 2~Java 8）</strong></h4><pre class="mermaid">classDiagram
    启动类加载器 <|-- 扩展类加载器
    扩展类加载器 <|-- 应用程序类加载器
    应用程序类加载器 <|-- 自定义类加载器1
    应用程序类加载器 <|-- 自定义类加载器2
    应用程序类加载器 <|-- 自定义类加载器3</pre>

<p>三层类加载器：</p>
<ul>
<li><p>启动类加载器：加载<code>%JAVA_HOME%\lib</code>目录下的类库，仅按名字识别（如rt.jar等），<strong>无法直接引用</strong></p>
</li>
<li><p>扩展类加载器：加载<code>%JAVA_HOME%\lib\ext</code>目录下的类库，可直接使用Java代码引用</p>
</li>
<li><p>应用程序类加载器：加载<code>%CLASSPATH%</code>目录下的类库，一般是用户指定的一些类库。<strong>应用程序在未实现自定义的加载器的情况下使用的都是此加载器</strong></p>
<blockquote>
<p>应用程序类加载器使用时。当某个被依赖的类缺失，只有在这个类被加载、链接时才会报异常。</p>
</blockquote>
</li>
</ul>
<p><strong>双亲委派模型</strong>：</p>
<p>​    <u>所有类加载器在收到类加载的请求时，首先不会自己尝试加载相应的类，而是委派给父加载器去完成（除了顶层的启动类加载器）。父加载器反馈无法完成时则自己尝试加载。</u></p>
<p>​    这可保证安全，如自定义实现了一个Object类尝试进行加载，会报SecurityException。并且保证基础类库中的类永远只有一种（类相等判定为一种，这种意义上）</p>
<h4 id="模块化系统（Java-9-现在）"><a href="#模块化系统（Java-9-现在）" class="headerlink" title="模块化系统（Java 9~现在）"></a><strong>模块化系统（Java 9~现在）</strong></h4><p>模块（module）新增的包含内容：依赖模块列表、导出包列表（其他模块可使用）、开放包列表（其他模块可反射访问）、使用与提供的服务列表。</p>
<blockquote>
<p>模块化封装后，可显式声明对其他模块的依赖，这在启动时便可检查出类缺失异常。（这仅在模块未被修改的情况下成立，如果删除某个类但并不更新导出包列表，那么使用此类的模块在启动时依旧检查不到错误）</p>
</blockquote>
<p>模块化系统兼容传统的JAR包，<strong>类库视作传统JAR包还是模块仅取决于所在路径是CLASSPATH还是MODULEPATH</strong>，并规定了以下访问规则来兼容：</p>
<ul>
<li>JAR位于CLASSPATH时：所有JAR及资源文件视为<strong>匿名模块</strong>，所有CLASSPATH、MODULEPATH以及JDK系统模块均对其可见</li>
<li>模块位于MODULEPATH时：视为<strong>命名模块</strong>，只能访问到模块自己定义的依赖模块，JAR对其不可见</li>
<li>JAR位于MODULEPATH时：视为<strong>自动模块</strong>，默认对所有模块可见，也导出自己所有的包</li>
</ul>
<p>由于模块系统取代了原有的传统JAR包封装方式，因此三层类加载器中的<u>扩展类加载器</u>被<u>平台类加载器</u>取代，目前的类加载器体系如下</p>
<pre class="mermaid">classDiagram
    启动类加载器 <|-- 平台类加载器
    平台类加载器 <|--|> 应用程序类加载器
    启动类加载器 <|-- 应用程序类加载器
    应用程序类加载器 <|-- 自定义类加载器1
    应用程序类加载器 <|-- 自定义类加载器2
    应用程序类加载器 <|-- 自定义类加载器3</pre>

<p><em>mermaid插件渲染还有问题，这个图里的箭头都显示不出来</em></p>
<p>目前严格来说已经不能算是双亲委派模型，<strong>这三层类加载器各自负责一部分模块的加载，在委派给父加载器前，会先检查要加载的类能否归属到某个系统模块中，如果可以则优先使用对应模块的类加载器进行加载。</strong></p>
</div></article></div><div class="article"><hr><h2>版权声明</h2>| 文章作者：<a href="https://champagne0418.github.io">chengxiaoke</a><br>| 文章链接：<a href="https://champagne0418.github.io/2020/12/03/java-jvm-classloading/">https://champagne0418.github.io/2020/12/03/java-jvm-classloading/</a><br>| 许可协议：<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a><hr></div></main><footer><div class="paginator"></div><div class="clearfix"></div><div class="copyright"><p id="host_by"> <a href="/atom.xml"><i class="fa fa-rss"></i></a><span id="busuanzi_container_site_pv">&nbsp;<i class="fa fa-eye">&nbsp;</i><span id="busuanzi_value_site_pv"><i class="fa fa-spinner"></i></span> times, </span><span id="busanzi_container_site_uv">&nbsp;<i class="fa fa-user">&nbsp;</i><span id="busuanzi_value_site_uv"><i class="fa fa-spinner"></i></span> times.</span><br> &copy; 2020 <a href="https://champagne0418.github.io">chengxiaoke</a>. 
 Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/wwwuxt/hexo-theme-artemisX" target="_blank">ArtemisX</a>.<br></p><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-108353521-1']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
console.log('Google Analytics')
</script><script>(function(){
    var req = GetXmlHttpObject()  
    if (req == null) {  
        console.log("not support AJAX!");  
        return;  
    }
    req.onreadystatechange = function() {  
        if (req.readyState === 4 && req.status === 200) {  
            var deploy_server = req.getResponseHeader("Server");
            console.log(deploy_server)
            if(deploy_server === 'Coding Pages'){
                document.getElementById('host_by').innerHTML+='Hosted by <a target="_blank" rel="noopener" href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>.'
            }
            else if(deploy_server === 'GitHub.com'){
                document.getElementById('host_by').innerHTML+='Hosted by <a target="_blank" rel="noopener" href="https://pages.github.com" style="font-weight: bold">GitHub Pages</a>.'
            }
            else{
                document.getElementById('host_by').innerHTML+='Hosted by <a href="#" style="font-weight: bold">'+ deploy_server + '</a>.'
            }
        }  
    };  
    req.open('GET', document.location, true);
    req.send(null);
})();
function GetXmlHttpObject() {  
    var xmlHttp = null;  
    try {  
        // Firefox, Opera 8.0+, Safari  
        xmlHttp = new XMLHttpRequest();  
    } catch (e) {  
        // Internet Explorer  
        try {  
            xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");  
        } catch (e) {  
            xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");  
        }  
    }  
    return xmlHttp;  
}  </script><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;startOnload&quot;:true}" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></body></html>